package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/cheggaaa/pb"
	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/btf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
	"golang.org/x/sys/unix"

	"github.com/ZhangYet/dust/internal/dust"
)

func main() {
	if err := unix.Setrlimit(unix.RLIMIT_NOFILE, &unix.Rlimit{
		Cur: 8192,
		Max: 8192,
	}); err != nil {
		log.Fatalf("failed to set temporary rlimit: %s", err)
	}
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("Failed to set temporary rlimit: %s", err)
	}

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	btfSpec, err := btf.LoadKernelSpec()
	if err != nil {
		log.Fatalf("Failed to load BTF spec: %s", err)
	}
	funcs, err := dust.GetFuncs("", btfSpec, []string{}, false)
	if err != nil {
		log.Fatalf("Failed to get skb-accepting functions: %s", err)
	}

	addr2name, _, err := dust.ParseKallsyms(funcs, false)
	if err != nil {
		log.Fatalf("Failed to parse Kallsyms: %s", err)
	}

	var bpfSpec *ebpf.CollectionSpec
	bpfSpec, err = LoadKProbeRequest() // generated by `go generate`
	if err != nil {
		log.Fatalf("Failed to load bpf spec: %s", err)
	}

	var opts ebpf.CollectionOptions
	opts.Programs.KernelTypes = btfSpec
	opts.Programs.LogLevel = ebpf.LogLevelInstruction
	opts.Programs.LogSize = ebpf.DefaultVerifierLogSize * 100

	coll, err := ebpf.NewCollectionWithOptions(bpfSpec, opts)
	if err != nil {
		var (
			ve          *ebpf.VerifierError
			verifierLog string
		)
		if errors.As(err, &ve) {
			verifierLog = fmt.Sprintf("Verifier error: %+v\n", ve)
		}

		log.Fatalf("Failed to load objects: %s\n%+v", verifierLog, err)
	}
	defer coll.Close()

	var kprobes []link.Link
	defer func() {
		dust.DetachKprobes(kprobes, 0)
	}()

	msg := "kprobe"
	log.Printf("Attaching kprobes (via %s)...\n", msg)

	ignored := 0
	bar := pb.StartNew(len(funcs))

	dustKprobes := make([]dust.Kprobe, 0, len(funcs))
	funcsByPos := dust.GetFuncsByPos(funcs)
	for pos, fns := range funcsByPos {
		fn, ok := coll.Programs[fmt.Sprintf("kprobe_dust_%d", pos)]
		if ok {
			dustKprobes = append(dustKprobes, dust.Kprobe{HookFuncs: fns, Prog: fn})
		} else {
			ignored += len(fns)
			bar.Add(len(fns))
		}
	}

	retProg, ok := coll.Programs["alloc"]
	if !ok {
		log.Fatalf("Failed to find kretprobe_alloc_request")
	}
	retLink, err := link.Kretprobe("blk_mq_alloc_request", retProg, nil)
	if err != nil {
		log.Fatalf("Failed to attach kretprobe_alloc_request: %s", err)
	}
	defer retLink.Close()

	l, i := dust.AttachKprobes(ctx, bar, dustKprobes, 10)
	kprobes = append(kprobes, l...)
	ignored += i

	bar.Finish()
	select {
	case <-ctx.Done():
		return
	default:
	}
	log.Printf("Attached (ignored %d)\n", ignored)

	log.Println("Listening for events..")

	output, err := dust.NewOutput(nil, nil, nil, addr2name, false, btfSpec)
	if err != nil {
		log.Fatalf("Failed to create output: %s", err)
	}
	defer output.Close()

	output.PrintHeader()

	defer func() {
		select {
		case <-ctx.Done():
			log.Println("Received signal, exiting program..")
		default:
			log.Printf("Printed %d events, exiting program..\n", 100)
		}
	}()

	var event dust.Event
	events := coll.Maps["events"]
	for i := 100; i > 0; i-- {
		for {
			if err := events.LookupAndDelete(nil, &event); err == nil {
				break
			} else {
				var (
					ve          *ebpf.VerifierError
					verifierLog string
				)
				if errors.As(err, &ve) {
					verifierLog = fmt.Sprintf("Verifier error: %+v\n", ve)
				}

				log.Fatalf("Failed to load objects: %s\n%+v", verifierLog, err)
			}
			/*
				select {
				case <-ctx.Done():
					return
				case <-time.After(time.Microsecond):
					continue
				}*/
		}
		output.Print(&event)
		select {
		case <-ctx.Done():
			return
		default:
		}
	}
}
